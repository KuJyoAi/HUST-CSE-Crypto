# 运输层

## 3.1 运输层概述

### 功能

- 为不同主机上运行的应用进程之间提供逻辑通信

### 工作内容

- 发送方：把应用数据划分成报文段(segments),交给网络层(从应用层获取,交付到网络层)
- 接收方：把报文段重组成应用数据，交付给应用层(从网络层获取,交付到应用层)

### 协议簇

- TCP
- UDP

### 功能

- 进程间交付 3.2
- 差错检测 3.3
- 可靠数据传输 3.4 3.5
- 拥塞控制 3.6

## 3.2 复用和分解

### 端口

- 一个应用层和运输层的桥梁

	- 应用层可以通过端口获得传输层递交的数据
	- 传输层可以通过端口向应用层递交数据

- 一个主机应用进程的标记

### 套接字

- TCP的基础:“连接”,将连接用套接字标记
- UDP套接字

	- 目的端口
	- 目的地址

- TCP套接字

	- 目的端口
	- 目的地址
	- 源端口
	- 源地址

- 多路复用

	- 运输层从主机的不同套接字中收集数据,为数据加上首部信息转发到网络层
	- 多个来源一个目的,不同套接字的数据转发到一个出口(即网络层)

- 多路分解

	- 运输层的报文段根据首部交付到正确的套接字
	- 一个来源多个目的,一个网络层的数据可以根据套接字的不同转发到不同的端口

## 3.3 UDP和差错检验

### 流程

- 发送方

	- 从应用进程获得数据
	- 加上目的端口号,形成报文段
	- 递交给网络层,尽力而为地交付

- 接收方

	- 从网络层获得报文段,直接交付给应用层
	- 没有响应

### 特点

- 无连接的
- 分组开销小
- 在应用层实现可靠传递
- 容易击垮TCP连接

### UDP报文段的首部

- 源端口号
- 目的端口号
- 长度
- 检验和

### 检验和

- 将报文段里面的内容按照16位为单位,每个16位元素进行相加构成检验和
- 如果出现了溢出,一定要做回卷

## 3.4 可靠传输原理

### rdt系列

- rdt1.0
- rdt2.0
- rdt2.1
- rdt2.2
- rdt3.0

	- 发送方

		- 在等待状态应用层数据状态,收到应用层数据,就向网络层转发,并启动定时器
		- 收到不对的ACK(期望为0却是1),重传
		- 超时,重传,并启动定时器.

	- 接收方

		- 收到了错的分组,就发送上一次正确收到分组的序号的ACK(期待0号元素,收到了1号元素就发送ACK1)
		- 收到了对的分组就发送正确的ACK

### GBN

- 发送方

	- 数据结构

		- 滑动窗口
		- base:滑动窗口的第一个元素
		- Nextseq:滑动窗口中第一个“未发送”的序号,下一次发送就发送这个序号的分组

	- 收到应用层

		- 如果有位置,就放入滑动窗口,Nextseq+1
		- 没位置就拒绝

	- 收到ACK

		- 如果和base一样,base+1,定时器置0

			- 滑动窗口里面还有已经发送没确认的元素,继续计时
			- 滑动窗口里面已经没有已经发送没确认的元素,就不计时了

		- 如果不和base一样,不管

	- 超时

		- 重新传输滑动窗口内已经发送的但是没有确认的元素

- 接受方

	- 数据结构

		- 期待收到的元素Exc
		- 上一次收到的规律分组序号n

	- 收到期望的分组

		- 发送ACK(Exc),Exc++

	- 收到乱序分组

		- 发送ACK(n)

### SR

- 发送方

	- 数据结构

		- 滑动窗口
		- base:滑动窗口的第一个元素
		- Nextseq:滑动窗口中第一个“未发送”的序号,下一次发送就发送这个序号的分组
		- 每个分组都有一个定时器

	- 收到应用层

		- 如果有位置,就放入滑动窗口,Nextseq+1
		- 没位置就拒绝

	- 收到ACK

		- 标记分组 n 为已接收
		- 如果n是发送窗口基序号base，则将窗口基序号前推到下一个未确认序号

	- 超时

		- 哪个分组的定时器超时了就重传谁

- 接受方

	- 数据结构

		- 接受滑动窗口

			- 标记收到还是没收到

	- 收到分组

		- 发送n的确认ACK(n)
		- 如果分组序号不连续(失序)：将其缓存
		- 按序分组: 将该分组以及以前缓存的序号连续的分组一起交付给上层, 将窗口前推到下一个未收到的分组

## 3.5 TCP

### 报文首部

- 源端口号
- 目的端口号
- 长度
- 检验和
- 序列号

	- 在报文段数据中第一个字节在字节流中的编号

- 确认号

	- 期待得到的下一个字节的seq
也就是说1-seq-1字节已经被确认,seq没有

### 超时设置

- SampleRTT

	- 对报文段被发出到收到该报文段的确认之间的时间进行测量

- EstimatedRTT

	- EstimatedRTT = (1- a)*EstimatedRTT + a*SampleRTT
	- 第一次:EstimatedRTT=SampleRTT

- DevRTT

	- DevRTT = (1-b)*DevRTT +b*|SampleRTT-EstimatedRTT|
	- 第一次:DevRTT=0.5*SampleRTT

### 可靠传输协议

- 发送方

	- 收到应用层数据

		- 将数据封装入报文段中，每个报文段都包含一个序号
		- 序号是该报文段第一个数据字节的字节流编号
		- 启动定时器
		- 超时间隔: TimeOutInterval 
		- 一个报文段一个定时器

	- 超时

		- 重传认为超时的报文段
		- 重启定时器

	- 收到ACK

		- 如果是对以前的未确认报文段的确认

			- 更新SendBase
			- 如果当前有未被确认的报文段，TCP还要重启定时器

- 接受方

	- 收到一个一个正常的分组(按序分组)

		- 等待500ms,等待收取第二个按序分组
		- 如果500ms没收到,那就只发这个
		- 如果500ms内收到了,就按照第二个来的分组发送ACK.

	- 收到一个乱序分组

		- 立即发送冗余ACK，指明下一个期待字节的序号

- 快速重传

	- 收到三个冗余ACK

		- 确认数据之后的报文段丢失,重传

### TCP建立的过程

- 客户机发送SYN
- 服务器接受SYN,返回SYN&ACK
- 客户机接受服务器SYN和ACK,回应ACK
- 服务器接受ACK,TCP建立完成

### TCP断开的过程

- 客户机发送FIN
- 服务器接受客户机的FIN,回应ACK和FIN
- 客户机接受ACK和FIN,发送ACK
- 服务器接受ACK,连接断开
- 客户机不会向服务器发送消息,但是服务器还是可以向客户机发送消息(半关闭)

## 3.6&3.7 拥塞控制

### 拥塞控制方法

- 网络辅助的拥塞控制
- 端到端的控制

### TCP Reno

- 拥塞窗口

	- 标记为CongWin,滑动窗口小于等于拥塞窗口
取接受滑动窗口和拥塞窗口最小值

- 慢启动

	- 每过一个RTT,拥塞窗口大小是之前的两倍
	- 每收到一个ACK,拥塞窗口大小+一个MSS

- 拥塞避免

	- 每过一个RTT,拥塞窗口大小是之前的加一
	- 拥塞窗口的大小大于ssthresh(门限值)进入拥塞避免
	- 每收到一个ACK,拥塞窗口大小+一个MSS*(MSS/窗口大小)

- 三个冗余ACK

	- 门限值=原拥塞窗口一半
	- 拥塞窗口=原拥塞窗口一半+3

- 超时

	- 门限值=原拥塞窗口一半
	- 拥塞窗口=1

### 公平性

- 如果K个TCP连接共享同一个带宽为R的瓶颈链路, 每个连接的平均传输速率为 R/K

### 吞吐量

- 一个公式

## TCP还是采用这个

## 传输轮回指的就是发出去的包,ACK全部都收回来了,就是指一个传输轮回,这样这个轮回就结束了,准备下一个轮回

*XMind - Trial Version*